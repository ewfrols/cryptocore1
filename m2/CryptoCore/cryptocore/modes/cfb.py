#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Реализация режима CFB (Cipher Feedback)
"""
from cryptocore.modes.base_mode import BaseMode
from cryptocore.crypto.aes_core import AESCore


class CFBMode(BaseMode):
    """Режим Cipher Feedback (потоковый)"""
    
    def __init__(self, ключ: str):
        super().__init__(ключ)
        self.требует_дополнения = False
    
    def зашифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Шифрование в режиме CFB
        """
        if iv is None:
            raise ValueError("Для CFB режима IV должен быть указан")
        
        зашифрованные_данные = b''
        регистр = iv  # Начинаем с IV
        
        for i in range(0, len(данные), AESCore.БЛОК_РАЗМЕР):
            # Шифруем текущее значение регистра
            зашифрованный_регистр = AESCore.шифровать_блок(self.шифрователь, регистр)
            
            # Берем текущий блок данных
            текущий_блок = данные[i:min(i + AESCore.БЛОК_РАЗМЕР, len(данные))]
            
            # XOR шифрованного регистра с данными
            if len(текущий_блок) < AESCore.БЛОК_РАЗМЕР:
                блок_для_xor = зашифрованный_регистр[:len(текущий_блок)]
            else:
                блок_для_xor = зашифрованный_регистр
            
            зашифрованный_блок = self.xor_блоков(текущий_блок, блок_для_xor)
            зашифрованные_данные += зашифрованный_блок
            
            # Регистр обновляется зашифрованными данными
            регистр = зашифрованный_блок
            
            # Дополняем до размера блока, если нужно
            if len(регистр) < AESCore.БЛОК_РАЗМЕР:
                регистр = регистр.ljust(AESCore.БЛОК_РАЗМЕР, b'\x00')
        
        return зашифрованные_данные
    
    def расшифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Расшифровка в режиме CFB
        """
        if iv is None:
            raise ValueError("Для CFB режима IV должен быть указан")
        
        расшифрованные_данные = b''
        регистр = iv  # Начинаем с IV
        
        for i in range(0, len(данные), AESCore.БЛОК_РАЗМЕР):
            # Шифруем текущее значение регистра
            зашифрованный_регистр = AESCore.шифровать_блок(self.шифрователь, регистр)
            
            # Берем текущий блок зашифрованных данных
            текущий_блок = данные[i:min(i + AESCore.БЛОК_РАЗМЕР, len(данные))]
            
            # XOR шифрованного регистра с зашифрованными данными
            if len(текущий_блок) < AESCore.БЛОК_РАЗМЕР:
                блок_для_xor = зашифрованный_регистр[:len(текущий_блок)]
            else:
                блок_для_xor = зашифрованный_регистр
            
            расшифрованный_блок = self.xor_блоков(текущий_блок, блок_для_xor)
            расшифрованные_данные += расшифрованный_блок
            
            # КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: 
            # В CFB регистр обновляется ТЕКУЩИМИ ВХОДНЫМИ ДАННЫМИ (зашифрованными)
            регистр = текущий_блок
            
            # Дополняем до размера блока, если нужно
            if len(регистр) < AESCore.БЛОК_РАЗМЕР:
                регистр = регистр.ljust(AESCore.БЛОК_РАЗМЕР, b'\x00')
        
        return расшифрованные_данные