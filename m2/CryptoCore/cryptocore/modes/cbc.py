#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Реализация режима CBC (Cipher Block Chaining)
"""
from cryptocore.modes.base_mode import BaseMode


class CBCMode(BaseMode):
    """Режим Cipher Block Chaining"""
    
    def __init__(self, ключ: str):
        super().__init__(ключ)
        self.требует_дополнения = True
    
    def зашифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Шифрование в режиме CBC
        
        Args:
            данные: Данные для шифрования
            iv: Вектор инициализации (16 байт). Если None - будет сгенерирован
            
        Returns:
            bytes: Зашифрованные данные
        """
        if iv is None:
            # Для CBC IV должен быть указан, генерируем позже
            raise ValueError("Для CBC режима IV должен быть указан")
        
        # Подготавливаем данные (добавляем padding)
        подготовленные_данные = self.подготовить_данные_для_шифрования(данные)
        
        # Шифруем блок за блоком
        зашифрованные_данные = b''
        предыдущий_блок = iv
        
        for i in range(0, len(подготовленные_данные), AESCore.БЛОК_РАЗМЕР):
            текущий_блок = подготовленные_данные[i:i + AESCore.БЛОК_РАЗМЕР]
            
            # XOR с предыдущим зашифрованным блоком (или IV для первого блока)
            блок_для_шифрования = self.xor_блоков(текущий_блок, предыдущий_блок)
            
            # Шифруем блок
            зашифрованный_блок = AESCore.шифровать_блок(self.шифрователь, блок_для_шифрования)
            зашифрованные_данные += зашифрованный_блок
            
            # Обновляем предыдущий блок для следующей итерации
            предыдущий_блок = зашифрованный_блок
        
        return зашифрованные_данные
    
    def расшифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Расшифровка в режиме CBC
        
        Args:
            данные: Зашифрованные данные
            iv: Вектор инициализации (16 байт)
            
        Returns:
            bytes: Расшифрованные данные
        """
        if iv is None:
            raise ValueError("Для CBC режима IV должен быть указан")
        
        # Проверяем что данные кратны размеру блока
        if len(данные) % AESCore.БЛОК_РАЗМЕР != 0:
            raise ValueError(f"Данные должны быть кратны {AESCore.БЛОК_РАЗМЕР} байтам")
        
        # Расшифровываем блок за блоком
        расшифрованные_данные = b''
        предыдущий_зашифрованный_блок = iv
        
        for i in range(0, len(данные), AESCore.БЛОК_РАЗМЕР):
            текущий_зашифрованный_блок = данные[i:i + AESCore.БЛОК_РАЗМЕР]
            
            # Расшифровываем блок
            расшифрованный_блок = AESCore.расшифровать_блок(self.шифрователь, текущий_зашифрованный_блок)
            
            # XOR с предыдущим зашифрованным блоком (или IV для первого блока)
            оригинальный_блок = self.xor_блоков(расшифрованный_блок, предыдущий_зашифрованный_блок)
            расшифрованные_данные += оригинальный_блок
            
            # Обновляем предыдущий блок для следующей итерации
            предыдущий_зашифрованный_блок = текущий_зашифрованный_блок
        
        # Удаляем padding
        return self.обработать_расшифрованные_данные(расшифрованные_данные)