#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Реализация режима OFB (Output Feedback)
"""
from cryptocore.modes.base_mode import BaseMode


class OFBMode(BaseMode):
    """Режим Output Feedback (потоковый)"""
    
    def __init__(self, ключ: str):
        super().__init__(ключ)
        self.требует_дополнения = False
    
    def зашифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Шифрование в режиме OFB
        
        Args:
            данные: Данные для шифрования
            iv: Вектор инициализации (16 байт). Если None - будет сгенерирован
            
        Returns:
            bytes: Зашифрованные данные
        """
        if iv is None:
            raise ValueError("Для OFB режима IV должен быть указан")
        
        # Генерируем ключевой поток
        ключевой_поток = self.сгенерировать_ключевой_поток(len(данные), iv)
        
        # XOR ключевого потока с данными
        return self.xor_блоков(данные, ключевой_поток)
    
    def расшифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Расшифровка в режиме OFB (симметрична шифрованию)
        
        Args:
            данные: Зашифрованные данные
            iv: Вектор инициализации (16 байт)
            
        Returns:
            bytes: Расшифрованные данные
        """
        return self.зашифровать(данные, iv)
    
    def сгенерировать_ключевой_поток(self, размер_данных: int, iv: bytes) -> bytes:
        """
        Генерирует ключевой поток для OFB
        
        Args:
            размер_данных: Сколько байт ключевого потока нужно
            iv: Вектор инициализации
            
        Returns:
            bytes: Ключевой поток
        """
        ключевой_поток = b''
        текущее_состояние = iv
        
        while len(ключевой_поток) < размер_данных:
            # Шифруем текущее состояние
            зашифрованное_состояние = AESCore.шифровать_блок(self.шифрователь, текущее_состояние)
            
            # Добавляем к ключевому потоку
            ключевой_поток += зашифрованное_состояние
            
            # Обновляем состояние для следующей итерации
            текущее_состояние = зашифрованное_состояние
        
        # Обрезаем до нужного размера
        return ключевой_поток[:размер_данных]