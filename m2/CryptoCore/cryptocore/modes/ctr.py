#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Реализация режима CTR (Counter)
"""
import struct
from cryptocore.modes.base_mode import BaseMode


class CTRMode(BaseMode):
    """Режим Counter (потоковый)"""
    
    def __init__(self, ключ: str):
        super().__init__(ключ)
        self.требует_дополнения = False
    
    def зашифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Шифрование в режиме CTR
        
        Args:
            данные: Данные для шифрования
            iv: Nonce (16 байт). Если None - будет сгенерирован
            
        Returns:
            bytes: Зашифрованные данные
        """
        if iv is None:
            raise ValueError("Для CTR режима IV (nonce) должен быть указан")
        
        # Генерируем ключевой поток
        ключевой_поток = self.сгенерировать_ключевой_поток(len(данные), iv)
        
        # XOR ключевого потока с данными
        return self.xor_блоков(данные, ключевой_поток)
    
    def расшифровать(self, данные: bytes, iv: bytes = None) -> bytes:
        """
        Расшифровка в режиме CTR (симметрична шифрованию)
        
        Args:
            данные: Зашифрованные данные
            iv: Nonce (16 байт)
            
        Returns:
            bytes: Расшифрованные данные
        """
        return self.зашифровать(данные, iv)
    
    def сгенерировать_ключевой_поток(self, размер_данных: int, nonce: bytes) -> bytes:
        """
        Генерирует ключевой поток для CTR
        
        Args:
            размер_данных: Сколько байт ключевого потока нужно
            nonce: Начальное значение (первые 12 байт) + счетчик (последние 4 байта)
            
        Returns:
            bytes: Ключевой поток
        """
        ключевой_поток = b''
        блоков_нужно = (размер_данных + AESCore.БЛОК_РАЗМЕР - 1) // AESCore.БЛОК_РАЗМЕР
        
        for i in range(блоков_нужно):
            # Создаем значение счетчика
            # Первые 12 байт - nonce, последние 4 байта - счетчик
            if len(nonce) == 16:
                # Если nonce уже 16 байт, используем как есть
                значение_счетчика = nonce
                # Увеличиваем счетчик в последних 4 байтах
                счетчик = struct.unpack('>I', значение_счетчика[12:])[0] + i
                значение_счетчика = значение_счетчика[:12] + struct.pack('>I', счетчик)
            else:
                # Иначе создаем из nonce + счетчик
                значение_счетчика = nonce.ljust(12, b'\x00')[:12]
                значение_счетчика += struct.pack('>I', i)
                значение_счетчика = значение_счетчика.ljust(16, b'\x00')
            
            # Шифруем значение счетчика
            зашифрованный_счетчик = AESCore.шифровать_блок(self.шифрователь, значение_счетчика)
            ключевой_поток += зашифрованный_счетчик
        
        # Обрезаем до нужного размера
        return ключевой_поток[:размер_данных]