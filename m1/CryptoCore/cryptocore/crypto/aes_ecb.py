#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AES-128 ECB шифрование
"""
from Crypto.Cipher import AES
from .padding import PKCS7Дополнение


class AESECBШифрователь:
    """Шифрование и расшифровка AES-128 ECB"""
    
    РАЗМЕР_БЛОКА = 16  # Блок AES = 16 байт
    РАЗМЕР_КЛЮЧА = 16  # AES-128 = ключ 16 байт
    
    def __init__(self, ключ_hex: str):
        """
        Инициализация шифрователя
        
        Args:
            ключ_hex: Ключ как hex-строка (32 символа)
        """
        # Преобразуем hex-строку в байты
        ключ_байты = bytes.fromhex(ключ_hex)
        
        # Проверяем длину ключа
        if len(ключ_байты) != self.РАЗМЕР_КЛЮЧА:
            raise ValueError(f"Ключ должен быть {self.РАЗМЕР_КЛЮЧА} байт для AES-128")
        
        self.ключ = ключ_байты
        self.шифрователь = AES.new(self.ключ, AES.MODE_ECB)
    
    def зашифровать(self, открытый_текст: bytes) -> bytes:
        """
        Шифрует данные
        
        Args:
            открытый_текст: Исходные данные (любые байты)
            
        Returns:
            bytes: Зашифрованные данные
        """
        print(f"Шифруем {len(открытый_текст)} байт...")
        
        # 1. Добавляем дополнение
        данные_с_дополнением = PKCS7Дополнение.добавить_дополнение(открытый_текст)
        
        # 2. Шифруем блоками по 16 байт
        зашифрованные_данные = b''
        всего_блоков = len(данные_с_дополнением) // self.РАЗМЕР_БЛОКА
        
        for i in range(0, len(данные_с_дополнением), self.РАЗМЕР_БЛОКА):
            блок = данные_с_дополнением[i:i + self.РАЗМЕР_БЛОКА]
            зашифрованный_блок = self.шифрователь.encrypt(блок)
            зашифрованные_данные += зашифрованный_блок
            
            # Показываем прогресс для больших файлов
            номер_блока = i // self.РАЗМЕР_БЛОКА + 1
            if всего_блоков > 10 and (номер_блока % (всего_блоков // 10) == 0 or номер_блока == всего_блоков):
                прогресс = int(номер_блока / всего_блоков * 100)
                print(f"  Прогресс: {прогресс}% ({номер_блока}/{всего_блоков} блоков)")
        
        print(f"Зашифровано: {len(открытый_текст)} -> {len(зашифрованные_данные)} байт")
        return зашифрованные_данные
    
    def расшифровать(self, зашифрованные_данные: bytes) -> bytes:
        """
        Расшифровывает данные
        
        Args:
            зашифрованные_данные: Зашифрованные байты
            
        Returns:
            bytes: Расшифрованные данные
            
        Raises:
            ValueError: Если данные повреждены или неправильный формат
        """
        print(f"Расшифровываем {len(зашифрованные_данные)} байт...")
        
        # Проверяем что размер кратен 16
        if len(зашифрованные_данные) % self.РАЗМЕР_БЛОКА != 0:
            raise ValueError(f"Зашифрованные данные ({len(зашифрованные_данные)} байт) "
                           f"должны быть кратны {self.РАЗМЕР_БЛОКА}")
        
        # Расшифровываем блоками
        расшифрованные_данные = b''
        всего_блоков = len(зашифрованные_данные) // self.РАЗМЕР_БЛОКА
        
        for i in range(0, len(зашифрованные_данные), self.РАЗМЕР_БЛОКА):
            блок = зашифрованные_данные[i:i + self.РАЗМЕР_БЛОКА]
            расшифрованный_блок = self.шифрователь.decrypt(блок)
            расшифрованные_данные += расшифрованный_блок
            
            # Показываем прогресс для больших файлов
            номер_блока = i // self.РАЗМЕР_БЛОКА + 1
            if всего_блоков > 10 and (номер_блока % (всего_блоков // 10) == 0 or номер_блока == всего_блоков):
                прогресс = int(номер_блока / всего_блоков * 100)
                print(f"  Прогресс: {прогресс}% ({номер_блока}/{всего_блоков} блоков)")
        
        # Удаляем дополнение
        данные_без_дополнения = PKCS7Дополнение.удалить_дополнение(расшифрованные_данные)
        if данные_без_дополнения is None:
            raise ValueError("Неправильное дополнение! Возможно неверный ключ или поврежденные данные.")
        
        print(f"Расшифровано: {len(зашифрованные_данные)} -> {len(данные_без_дополнения)} байт")
        return данные_без_дополнения
    
    @staticmethod
    def протестировать():
        """Проверяет что шифрование работает правильно"""
        print("Тестируем AES шифрование...")
        
        тестовый_ключ = "000102030405060708090a0b0c0d0e0f"
        # ИСПРАВЛЕНО: используем encode для русского текста
        тестовый_текст = "Привет, мир! Тест на русском.".encode('utf-8')
        
        try:
            шифрователь = AESECBШифрователь(тестовый_ключ)
            
            # Шифруем
            зашифровано = шифрователь.зашифровать(тестовый_текст)
            
            # Расшифровываем
            расшифровано = шифрователь.расшифровать(зашифровано)
            
            # Проверяем что совпадает
            if расшифровано == тестовый_текст:
                print("✓ Тест пройден! Текст совпадает.")
                return True
            else:
                print("✗ Тест не пройден! Текст не совпадает.")
                return False
                
        except Exception as ошибка:
            print(f"✗ Ошибка при тестировании: {ошибка}")
            return False